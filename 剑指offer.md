





# 树链表数组

## 1 二维数组中的查找

暴力法

利用数组规律从左下找

## 2 替换空格

### Solution 1： StringBuilder

```
StringBuilder ret = new StringBuilder();
ret.append(" ");
ret.toString();
```

字符串转成字符数组

```
char[] tmp = s.toCharArray();
```

### Solution 2：StringBuffer 双指针

① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。

② 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。

③ 当 P2 遇到 P1 时（P2 <= P1），或者遍历结束（P1 < 0），退出。

## 6 从尾到头打印链表

### Solution 1：递归

github上的方法运行有误

### Solution 2：头插入

创建一个头结点

```java
while(listNode != null){
            ListNode memo = listNode.next;
            listNode.next = head.next;
            head.next = listNode;
            listNode = memo;
        }
```

### Solution 3：使用栈

遍历链表，栈内存放结点的数值

### Solution 4：用ArrayList函数

 from newcoder 利用ArrayList本身的函数add

```java
//其实也是利用了头插入的思想
list.add(0, listnode.val);
```

## 7 重建二叉树

### Solution 1：递归调用

1. 给定节点数为 n 二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。
2. 前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分
3. 左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。
4. 然后分别对左右子树递归地求解。

## 8 二叉树的下一个结点

### Solution 1：分类讨论

我自己想的。

中序遍历顺序：左，根， 右

1. 结点存在右子树，返回右子树最左

2. 不存在右子树，找父结点

   1. 如果是父结点的左子树，返回父结点
   2. 如果是父结点的右子树，继续找父结点

   一直找，直到父结点为null，返回null即可

### Solution 2：中序遍历返回匹配结点

先找到所给结点的树对应的根结点，然后进行中序遍历。

## 18.1 在O(1)时间内删除结点

① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。

② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。

综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N ~ 2，因此该算法的平均时间复杂度为 O(1)。

## 19 顺时针打印矩阵

简单来说，就是不断地收缩矩阵的边界

时间复杂度O(n) 空间复杂度O(1)

定义四个变量代表范围，up、down、left、right

1. 向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错
2. 向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错
3. 向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错
4. 向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错



## 20 包含min函数的栈

### Solution 1：两个栈

一个栈存入栈的，令一个栈存当前最小的

(3 2 1 4) --- (3 2 1 1)

### Solution 2：单个栈

那么为了实现这一目的，在栈中需要保留冗余的曾经的最小值，这样能够比较方便到找到当前的此小值

## 21 栈的压入弹出序列

使用一个栈来模拟压入弹出操作。每次入栈一个元素后，都要判断一下栈顶元素是不是当前出栈序列 popSequence 的第一个元素，如果是的话则一直执行出栈操作并将 popSequence 往后移一位，直到不符合条件，继续进行判断。

## 22 链表中倒数最后k个结点

### Solution 1：运用两个指针，k和n-k关系

### Solution 2：压栈处理

弹出最后k个栈

### Solution 3：递归求解

## 23 链表中环的入口结点

### Solution 1：双指针

利用快慢指针走，第一次快慢指针重合时，再让临时指针从头结点开始走1步，慢指针从重合的地方走一步，当临时指针和慢指针重合时即为入口结点。

注意在第一次找快慢指针重合时，如果退出循环，不一定说明两个指针重合，也有可能不存在环，要记得判断

### Solution 2：寻找重复的值

利用HashMap存储结点的值，遍历链表走路一圈，遇到重复的说明有环。

但如果链表中的结点值有重复的，这种应该就不能用了。

## 24 反转链表

### Solution 1：头插入法

引入头结点

### Solution 2：递归

## 25 合并两个排序的链表

### Solution 1：递归

简单地理一下思路：

- 从头结点开始考虑，比较两表头结点的值，值较小的`list`的头结点后面接`merge`好的链表（进入递归了）；
- 若两链表有一个为空，返回非空链表，递归结束；
- 当前层不考虑下一层的细节，当前层较小的结点接上该结点的`next`与另一结点`merge`好的表头就ok了；
- 每层返回选定的较小结点就ok；

重新整理一下：

- 终止条件：两链表其中一个为空时，返回另一个链表；
- 当前递归内容：若`list1.val <= list2.val` 将较小的`list1.next`与merge后的表头连接，即`list1.next = Merge(list1.next,list2);` `list2.val`较大时同理；
- 每次的返回值：排序好的链表头；

### Solution 2：迭代

通过设立头结点，然后遍历两个链表，按顺序插在头结点后面。

## 26 树的子结构

### Solution 1：递归

1. 先写一个方法，传入两棵根结点值相同的树，判断t1和t2的结构是否一样
2. 再写一个方法遍历大树，找到一个和小树根节点值相等的节点，以该节点和小树根节点的值为参数调用上面的方法。

## 27 二叉树的镜像

### Solution 1：递归调用

交换左右子树节点

### Solution 2：BFS

运用队列，交换左右子树后，先将交换后的左子树加入队列，再将右子树加入队列

### Solution 3：DFS

运用栈，根节点压栈后，出栈结点交换左右结点，再将左结点入栈，右节点入栈。

## 28 对称的二叉树

### Solution 1：递归

1. 根节点是否为null

2. 判断左右子树是否对称

   这里需要另开一个新方法判断是否对称，即判断左子树的左孩子和右子树的右孩子相等吗，左子树的右孩子和右子树的左孩子相等吗

```java
if(l == null && r == null)
    return true;
if(l == null && r != null)
    return false;
if(l != null && r == null)
    return false;
```

上面可以简化为下面

```java
if (node1 == null && node2 == null) {
    return true;
} else if (node1 == null || node2 == null) {
    return false;
}
```

### Solution 2：非递归

设置两个链表，分别代表`左子树`和`右子树`。左子树每次都从左往右添加节点，右子树每次都从右往左添加节点。

## 29 最小的K个数

思路1 全排序然后找出靠前的K个

思路2 定义优先队列， 取头部的K个数

思路3 这题更多考的是堆

### Solution 1：堆

堆可以被看成完全二叉树的数组

大顶堆：节点大于左右孩子节点。

小顶堆：节点小于左右孩子节点

> 节点规律

root节点的下标从0开始，对于某一个节点index，左孩子L：2\*index+1, 右孩子R：2\*index+2

非叶子结点下标=结点个数/2 -1

> 大顶堆的建立

从非叶子节点开始维护

![image-20211010105719919](image-20211010105719919.png)

### Solution 2：快速排序

- 复杂度：O(N) + O(1)
- 只有当允许修改数组元素时才可以使用

快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。

会把数组中的一个数当做基准数，一般把数组中最左边的当做基准数，从两边进行检索，先从右边检索比基准数小的，然后再从左边检索比基准数大的，如果检索到了就停下来，交换两个元素，再继续检索。

一旦i和j相遇，就停止检索，把基准数和相遇位置的元素交换，表示第一轮排序结束。特点：基准数左边都比他小，右边都比他大。

第二轮：先拍基准数左边，排完之后再排基准数右边，方式和第一轮一样。

```java
private void quickSort(int[] arr, int left, int right){
    //进行判断，如果左边索引比右边索引大，直接return
    if(left > right)
        return;
    //定义变量保存基准数
    int base = arr[left];
    //定义变量i 指向最左边
    int i = left;
    //定义变量j 指向最右边
    int j = right;
    //i != j 在循环中进行检索
    while( i != j){
        //先由j从右往左检索比基准数小的就停下
        //检索到比基准数大的或相等 就继续检索
        while(arr[j] >= base && i < j){
            j--; //j从右往左移动
        }
        while(arr[i] <= base && i < j){
            i++;
        }
        //代码走到这里，说明i停下 j停下 然后交换i和j
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    //while条件不成立 就会向下执行
    //即i和j相遇 交换基准数和相遇位置的元素
    //把相遇位置的元素赋值给基准数位置的元素
    arr[left] = arr[i];
    arr[i] = base;

    //基准数在这里就归位，左边比他小 右边比他大
    //排基准数左边
    quickSort(arr, left, i - 1);
    quickSort(arr, i + 1, right);
} 
```

## 32 从上往下打印二叉树

### Solution 1：运用队列进行层次遍历

实际上跟BFS一样的道理

## 33 二叉搜索树的后序遍历序列

### Solution 1：分治递归

（1）将数组的元素分为两部分：左子树序列值和右子树序列值，左子树值都小于根节点值，右子树值都大于根节点值

（2）分别对左右子树序列值进行（1）方法递归，如果递归过程中发现其右子树序列中有值小于根节点值，则不是一个后续序列

### Solution 2：单调栈

1）初始化： 单调栈 stack ，父节点值 root（初始值为正无穷大，可把树的根节点看为此无穷大节点的左孩子）；
（2）倒序遍历数组：记每个节点为 ri ，判断： 若 ri > root ，说明此后序遍历序列不满足二叉搜索树定义，直接返回false ；
（3）更新父节点 root： 当栈不为空 且 ri < stack.peek() 时，循环执行出栈，并将出栈节点赋给 root 。
（4）入栈： 将当前节点 ri 入栈；
（5）若遍历完成，则说明后序遍历满足二叉搜索树定义，返回 true。

**这个没看懂**

## 34  二叉树中和为某一值的路径

==好难==

### Solution 1：递归

前置知识：

1. 首先清楚叶子的表示：如果节点为`root`, 那么当前节点为叶子节点的必要条件为`!root->left && !root->right`
2. 找出路径，当然需要遍历整棵树，这里采用先序遍历，即：`根节点，左子树，右子树`

递归算法三部曲：

1. 明白递归函数的功能：`FindPath(TreeNode* root,int sum)`，从root节点出发，找和为sum的路径

2. 递归终止条件：当root节点为叶子节点并且`sum==root->val`, 表示找到了一条符合条件的路径

3. 下一次递归：如果左子树不空，递归左子树`FindPath(root->left, sum - root->val)`,如果右子树不空，递归右子树，`FindPath(root->right, sum - root->val)`

   **看我的代码jz24解析。**

## 34 第一个只出现一次字符

### Solution 1：HashMap

**思路**

最直观的解法是使用 HashMap 对出现次数进行统计：字符做为 key，出现次数作为 value，遍历字符串每次都将 key 对应的 value 加 1。最后再遍历这个 HashMap 就可以找出出现次数为 1 的字符。

**用法**

HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。

HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。

HashMap 是无序的，即不会记录插入的顺序。

HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。

```java
//添加键值对
Sites.put(1, "Google");
//根据key得到Value
s.get(key);
//删除元素
s.remove(key);
//删除所有键值对
s.clear();
//计算键值对个数
s.size();
//得到所有value
s.values();
//得到所有key
s.keySet();
//判断是否为空
s.isEmpty();
//获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值。
hashmap.get(Object key, V defaultValue)
//如果 hashMap 中是否存在指定的 key 对应的映射关系返回 true，否则返回 false
hashmap.containsKey(Object key)
//如果 hashMap 中是否存在指定的 value 对应的映射关系返回 true，否则返回 false。
hashmap.containsValue(Object value)
//如果 oldValue 不存，对 key 对应对 value 执行替换，返回 key 对应的旧值，如果存在则替换成功返回 true。
hashmap.replace(K key, V oldValue, V newValue)
```

### Solution 2：ASCII

考虑到要统计的字符范围有限，也可以使用整型数组代替 HashMap。ASCII 码只有 128 个字符，因此可以使用长度为 128 的整型数组来存储每个字符出现的次数。

### Solution 3：BitSet类

**思路**

以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。

**用法**

一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。这和位向量（vector of bits）比较类似。

**我觉得可以看看 很巧妙**

## 35 复杂链表的复制

### Solution 1：多次遍历

我连题目都没看懂……

1. 在旧链表中创建新链表，此时不处理新链表的兄弟结点

   遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；

2. 根据旧链表的兄弟结点，初始化新链表的兄弟结点

   重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;

3. 从旧链表中拆分得到新链表

### Solution 2：HashMap建立新旧链表联系

1. 用一个 hashmap 建立新旧链表节点的对应的结点关系
2. 迭代旧链表，从而在 hashmap 中更新新链表的 next 与 random 两个字段

## 36 二叉搜索树与双向链表

==好难==

### Solution 1：中序遍历优化

对于二叉树进行中序遍历，在遍历的同时调整结点之间的指针，使之成为双向链表

1、特殊情况，二叉树为空，则直接返回 null

2、创建保留上一个结点 pre，返回链表结点 root

3、递归遍历左子树；root = pRootOfTree

4、遍历当前结点，并修改为双向链表 pRootOfTree.left=pre; pre.right=pRootOfTree; 

5、更新 pre = pRootOfTree

6、递归遍历右子树

7、递归结束返回 root

![图片说明](https://uploadfiles.nowcoder.com/images/20210630/751889074_1625032001405/27454066A99F333F2EF71AEF23113104)

## 37 序列化二叉树

### Solution 1：先序遍历

利用indexOf定位头结点，将头结点和剩下的序列化好的字符串分割

## 41 数据流中的中位数

### Solution 1：大顶堆&小顶堆

左边存放大顶堆，右边存放小顶堆，保证大顶堆所有数都小于小顶堆。

## 50 数组中重复的数字

### Solution 1：HashSet

HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。

HashSet 允许有 null 值。

HashSet 是无序的，即不会记录插入的顺序。

HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。

HashSet 实现了 Set 接口。

```java
    //添加元素
    set.add();
    //判断元素是否存在
    boolean flag = set.contains('a');
	//删除元素
	set.remove("a");
	//删除所有元素
	set.clear();
	//元素数量
	int num = set.size();
	//遍历
	for(String i: set){}
```

### Solution 2：替换法

要求时间复杂度 O(N)，空间复杂度 O(1)

```
遍历数组所有元素，交换不符合数组存放原则的元素：
  ``例如[2,3,1,0,2]
  ``遍历0位元素2：（交换0位元素2和2位元素1）->[1,3,2,0,2]
  ``遍历0位元素1：（交换0位元素1和1位元素3）->[3,1,2,0,2]
  ``遍历0位元素3：（交换0位元素3和3位元素0）->[0,1,2,3,2]
  ``依次遍历0、1、2、3位置元素，都符合存放原则numbers[i] = i，不做任何操作
  ``遍历末位元素2，此时末位元素2和2位元素2相等，出现了两次，即数字2位重复元素
```

## 52 两个链表的第一个公共结点

### Solution 1：HashSet

我自己想的方法，遍历两条链，存进HashSet之前判断是否存在ListNode，存在则说明就是公共结点。不能单纯判断ListNode.val是否相等，因为有可能存在重复的val。所以set里面存的是ListNode

### Solution 2：数学思维

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

## 54 二叉搜索树的第k个结点

### Solution 1：中序遍历栈实现

### Solution 2：中序遍历递归实现

## 55 二叉树的深度

### Solution 1：递归遍历

规律为结点所在的层 1 + max（左子树的高度，右子树的高度）

如果结点为空，返回0即可。

### Solution 2：层次遍历

我们先来回顾一下二叉树的层次遍历，一般我们都是用队列去实现的。

步骤：

1、先创建一个队列，将根节点入队；

2、队列不为空，进入循环：

- 出队一个节点
- 将当前节点的左右节点入队（不为空时）
- 此时当前层的所有节点的左右子节点都入队

4、最后当队列中无节点的时候，此时已全部遍历完全部节点。

有了上面的步骤，我们只需要在每一层的所有节点的左右子节点都入完队的时候，就计数，最后则可以得到结果。

其实就是在一行一行打印二叉树结点的基础上增加一个记录high的操作。

时间复杂度：O(n)。 节点的个数。

空间复杂度：O(n)。队列占用的空间。

### Solution 3：深度遍历

其实就是利用递归。

我们知道二叉树的深度，肯定是等于其左子树与右子树的深度的最大值再+1。（加1就是加上当前层）

深度遍历可以采用栈或者递归实现，本文采用递归的做法实现，代码很简单易懂。

当递归到节点为null的时候，则为终止条件，此时会返回0。

接着会取左右子树中最大值+1。

例子：

假设父节点F，左节点为L，L的左右节点都为null。

则此时父节点F的左子树的深度则为1。

时间复杂度：O(n)。 遍历的节点的个数。

空间复杂度：O(n)。退化成链表的时候，则递归深度为n。

## 57 和为S的两个数字

### Solution 1: 双指针

使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

- 如果两个指针指向元素的和 sum == target，那么这两个元素即为所求。
- 如果 sum > target，移动较大的元素，使 sum 变小一些；
- 如果 sum < target，移动较小的元素，使 sum 变大一些。

## 58 左旋转字符串

### Solution 1：对字符串进行操作

可以运用substring来截取然后再拼接

也可以用数组来存放字符，用队列记录需要左移的元素，然后调换位置

### Solution 2：字符串翻转

```
先将 "abc" 和 "XYZdef" 分别翻转，得到 "cbafedZYX"
然后再把整个字符串翻转得到 "XYZdefabc"。
```

字符串常用操作

```java
char[] c = str.toCharArray();
String str = new String(c);
str.substring(n);
```



## 59 滑动窗口的最大值

### Solution 1：PriorityQueue

运用大顶堆实现

## 68 树中两个结点的最低公共祖先

### 68.1 二叉查找树

[Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

### 68.2 普通二叉树

[Leetcode : 236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

### Solution 1：Recursive

1. 从根结点开始遍历树
2. 如果当前结点就是p或者q，标志mid为true，然后在左子树和右子树搜索另一个结点
3. 如果一个结点的左子树或右子树有该结点，返回true
4. 有3个指标 left right mid， 如果有三个中有两个是true，说明找到最低的公共结点。

### Solution 2：iterative using parent pointers

用两个指针从p和q开始去遍历他们的祖先，当两个指针重合时，所指的节点则是LCA.

1. 从根结点遍历树
2. 在找到p和q之前，在字典里存储指针。
3. 一旦我们找到p和q，可以从字典里得到p的所有祖先并构建一个祖先set。
4. 遍历q的祖先，如果q的祖先已经在p的祖先set里面，说明这就是LCA。

### Solution 3：



## 73 翻转单词序列

输入：

```
"nowcoder. a am I"
```

返回值：

```
"I am a nowcoder."
```

### Solution 1：StringBuilder + String.split

根据空格分隔单词，然后再重新拼接。记住，除了最后一个单词，其他单词拼接的时候后面要带空格！

### Solution 2：先翻转句子再翻转单词

也可以先翻转单词再翻转句子

```java
//char[] to string
String s = new String(array);
//char[] to string
String.valueOf(arr);
```

用两个指针定义单词的首字母和末字母

特别的，

```java
else if(end == arr.length || arr[end] == ' '){
                //要么尾部是空格，要么end刚刚超过数组最后一个角标，这两种情况就应该翻转了
                //end之所以会超过最后角标，是因为当最后一个字符不是空格时，会让end++，所以会越界
                reverse(arr, start, end-1);
                //翻转后，应该重新记录下个单词，因此更新end和start。
                end++;
                start = end;//这句和上一句可以写成start = ++end;
            }
```

### Solution 3: Stack

其实用栈就相当于Solution1里面的手动反转，也是利用了spilt函数

## 74 和为S的连续正数序列

### Solution 1：双指针

因为要求是连续正数序列，所以一开始定义start = 1, end = 2, tmpSum = 3;

然后进入循环，循环条件：

1. start < end
2. end < sum

循环内部：

1. tmpSum < sum 要增加多一个元素，右指针移动
2. tmpSum > sum 要减少一个元素，即减少最小的元素，左指针移动
3. tmpSum == sum 满足条件 记录下来，然后将左指针往后挪一个，右指针为左指针的下一个，重新计算tmpSum

## 75 字符流中第一个不重复的字符

### Solution 1：copy 34

建立一个StringBuffer来记录当前的字符串，但是这种方式不能通过newcoder的编译。虽然没有测试过，但我觉得逻辑是可行的

### Solution 2：Queue

来自github的方法。运用队列存储第一个出现一次的字符 + 用128位的数组来记录每个字符出现的次数

## 76 删除链表中重复的结点

### Solution 1： 递归调用删除结点

### Solution 2： 多次遍历 + set 

### Solution 3：一边遍历一边删除

## 77 按之字形顺序打印二叉树

### Solution 1：双重循环+队列+函数

跟78很类似，不过是加进tmpList的时候，通过增加一个boolean来判断要顺序插入还是倒序插入，如果是倒序则用tmp.add(0, val)进行倒序插入。

- list.add(T): 按照索引顺序从小到大依次添加
- list.add(index, T): 将元素插入index位置，index索引后的元素依次后移,这就完成了每一行元素的倒序，或者使用Collection.reverse()方法倒序也可以

### Solution 2：两个栈

先把根结点放入第一个栈，第一个栈的元素出栈，出栈结点的左右结点依次放入第二个栈中。

然后第二个栈元素出栈，出栈结点的左右结点依次放入第一个栈中，依次进行下去。

```java
int num = stack.size();
```

## 78 把二叉树打印成多行

### Solution 1：双重循环+队列

外层循环用于遍历树，即将结点加进去。内层循环则用于遍历队列，实现将同一层的poll出来，用que.size()作为约束条件。

核心思想：每次出队一个元素，就将该元素的孩子节点加入队列中，直至队列中元素个数为0时，出队的顺序就是该二叉树的层次遍历结果。

**和32从上往下打印链表非常相似**

## 79 平衡二叉树

除了solution 1，其他均来自newcoder

### Solution 1：计算二叉树深度+布尔变量

在`55 二叉树的深度基础`上，增加判断左右子树高度差是否超过1，如果超过1，则将全局布尔变量设置为false。

### Solution 2：对solution 1的优化以便提前返回

进行**剪枝**：当判断到左右子树的深度之差大于1的时候，则返回-1。每次递归结束判断返回值是否-1，若为-1，则立即返回。

时间复杂度：O(N)。N为树的节点个数。最差情况下需要遍历所有节点。

空间复杂度：O(N)。若树退化成了链表，则递归深度为节点的个数，需要用到O(N)的栈空间。

### Solution 3：暴力法自顶向下

##### 算法流程：

- 通过比较每个节点的左右子树的最大高度差, 来判断此子树是否是二叉平衡树。
- 若树的所有子树都平衡时，该树才是平衡二叉树。
- **时间复杂度 O(Nlog\*2N\*)**：最差情况下，需要遍历树所有节点判断是否平衡，需要O(N)。判断每个节点最大高度需要递归左右子树，需要占用 O(log2N)，所以总共占用O(Nlog2N)
  **空间复杂度O(\*N\*)**：最差情况下（树退化为链表时），递归需要使用*O*(*N*) 的栈空间。

```java
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) return true;
        // 高度差不能大于1，并且左右子树也是同样高度差要小于等于1
        return Math.abs(depth(root.left) - depth(root.right)) <= 1 && IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) {
            return 0;  
        } 
         // 左右子树中高度较大的作为当前节点高度
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
}

```

### Solution 4：自底向上递归

> 我感觉跟solution 2的剪枝没什么太大差别。

##### 算法流程：

- 判断空树，题目要求**空树也是平衡二叉树**
- 递归计算当前root**左右子树的高度差**
- 注意：递归过程中有左/右子树不平衡,则该树不平衡，相当于**可行性剪枝**，没必要遍历所有节点
- 递归到底后，**自底向顶**，每次+1，不断计算高度，直到递归到某个节点使得左右子树高度差大于1，则返回-1表示不平衡
- 左右子树中**高度较高**的, 作为当前节点的高度, 用于向上递归判断是否平衡
- 递归终止条件：
  - root 为 null
  - 左右子树高度差大于1，即左右子树其中一个节点返回-1，则递归终止，阻断递归，表示不是平衡二叉树
- 递归方法的功能：获取当前节点的树的高度

```java
public boolean IsBalanced_Solution(TreeNode root) {
        // 空树也是平衡二叉树
        if(root == null) {
            return true;
        }
        return getHeight(root) != -1;
    }
 
    public int getHeight(TreeNode root) {
        if(root == null) {
            return 0;
        }
        // 递归计算当前root左右子树的高度差
        int left = getHeight(root.left);
        // 当前节点左子树不平衡,则该树不平衡，相当于可行性剪枝，没必要遍历所有节点
        if(left < 0) {
            return -1;
        }
        int right = getHeight(root.right);
        if(right < 0) {
            return -1;
        }
        // 自底向顶，每次+1，不断计算高度，直到递归到某个节点使得左右子树高度差大于1，则返回-1表示不平衡
        // 左右子树中高度较高的, 作为当前节点的高度, 用于向上递归判断是否平衡
        return Math.abs(left - right) > 1 ? -1 : 1 + Math.max(left, right);
    }
```

# 贪心思想

## 14 剪绳子

[牛客网](https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&tqId=33257&tab=answerKey&from=cyc_github)

### Solution  1:：贪心

尽可能得多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。以下为证明过程。

将绳子拆成 1 和 n-1，则 1(n-1)-n=-1<0，即拆开后的乘积一定更小，所以不能出现长度为 1 的绳子。

将绳子拆成 2 和 n-2，则 2(n-2)-n = n-4，在 n>=4 时这样拆开能得到的乘积会比不拆更大。

将绳子拆成 3 和 n-3，则 3(n-3)-n = 2n-9，在 n>=5 时效果更好。

将绳子拆成 4 和 n-4，因为 4=2*2，因此效果和拆成 2 一样。

将绳子拆成 5 和 n-5，因为 5=2+3，而 5<2*3，所以不能出现 5 的绳子，而是尽可能拆成 2 和 3。

将绳子拆成 6 和 n-6，因为 6=3+3，而 6<3*3，所以不能出现 6 的绳子，而是拆成 3 和 3。这里 6 同样可以拆成 6=2+2+2，但是 3(n - 3) - 2(n - 2) = n - 5 >= 0，在 n>=5 的情况下将绳子拆成 3 比拆成 2 效果更好。

继续拆成更大的绳子可以发现都比拆成 2 和 3 的效果更差，因此我们只考虑将绳子拆成 2 和 3，并且优先拆成 3，当拆到绳子长度 n 等于 4 时，也就是出现 3+1，此时只能拆成 2+2。

 将绳子以相等的长度等分为多段 ，得到的乘积最大。

### Solution 2：动态规划

1. 将绳子分割的最优方案可以从比他短的绳子的最优最优方案中推出来，因此我们可以想到用动态规划来解决本题
2. 将绳子的长度作为状态，定义数组f[x]表示将长度为x的绳子分割成至少两段所能得到的最大乘积，假设已知f[2~x-1]的结果，那么我们可以枚举切出的第一段的长度j，故需考虑两种方案：

- 将x拆分为j和(x - j)这两段，且(x - j)不再继续拆分
- 将x拆分为j和(x - j)这两段，(x - j)继续拆分，最大值为f[x - j]

由于至少剪成两段故j的取值范围是[1, x)，根据题意f[0] = f[1] = 0
故状态转移方程如下：

$$f(i) = max(j*(i-j),j*f(i-j))(1 \le j \lt i)$$

【我感觉上面有误】

为什么是

```java
dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)))
```

### Solution 3：暴力法

暴力法，遍历可以分割的所有情况，取其中的最大值。在分析的思路里，对于子线段的长度范围是1 ~ (n-1)，实际上，只需要1 ~ (n/2)，因为大于n/2的情况，已经在前面出现过了，所以可以直接去掉。

### Solution 4：递归

## 63 股票的最大利润

[Leetcode：121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)

### Solution 1：暴力法

### Solution 2：贪心策略

使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。因此在遍历数组时记录当前最低的买入价格，并且尝试将每个位置都作为卖出价格，取收益最大的即可。

### Solution 3：One pass

跟贪心策略很像啊，就是找出最小的买入价以及最大的利润。

# 二分查找

## 11  旋转数组的最小数字

[牛客网](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)

### Solution 1： brute force

直接遍历找最小的

### Solution 2：二分查找

将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。新的旋转数组的长度是原数组的一半，从而将问题规模减少了一半，这种折半性质的算法的时间复杂度为 O(log2N)。

此时问题的关键在于确定对半分得到的两个数组哪一个是旋转数组，哪一个是非递减数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。

通过修改二分查找算法进行求解（l 代表 low，m 代表 mid，h 代表 high）：

- 当 nums[m] <= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时令 h = m；
- 否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。

如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。

## 53 数字在升序数组中出现的次数

[牛客网](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)

### Solution 1：brute force

暴力法 遍历计数

### Solution 2：二分查找

题目说的在升序数组找到一个目标，然后统计这个目标出现的次数，我们要好好利用升序数组这个条件。

有了这个条件，我们就可以算出这个目标值的左边界还有右边界，然后取两者之差即可统计出这个目标出现的次数。

因为我们要找到目标值的左边界和右边界，我们很容易能想到用二分查找去求。

那么，找出左边界其实很好找，那要怎么找到右边界呢，我们可以将右边界转化为求比目标值大的数的左边界来求。

也就是说，我们如果要 求数字 `4`的右边界，那我们其实可以求数字`5`的左边界然后也就知道了4的右边界了。

但是在查找第一个位置时，找到元素之后应该继续往前找。也就是当 nums[m]>=k 时，在左区间继续查找，左区间应该包含 m 位置。

查找最后一个位置可以转换成寻找 k+1 的第一个位置，并再往前移动一个位置。

# 分治

## 16 数值的整数次方

[牛客网](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)

### Solution 1：暴力解法

直接多个数相乘

小心指数为负！

### Solution 2：分治

最直观的解法是将 x 重复乘 n 次，x\*x\*x...\*x，那么时间复杂度为 O(N)。因为乘法是可交换的，所以可以将上述操作拆开成两半 (x\*x..\*x)* (x\*x..\*x)，两半的计算是一样的，因此只需要计算一次。而且对于新拆开的计算，又可以继续拆开。这就是分治思想，将原问题的规模拆成多个规模较小的子问题，最后子问题的解合并起来。

本题中子问题是 $x^{n/2}$，在将子问题合并时将子问题的解乘于自身相乘即可。但如果 n 不为偶数，那么拆成两半还会剩下一个 x，在将子问题合并时还需要需要多乘于一个 x。

$x^{n}=\left\{\begin{array}{rr}x^{n / 2} * x^{n / 2} & n \% 2=0 \\ x *\left(x^{n / 2} * x^{n / 2}\right) & n \% 2=1\end{array}\right.$

因为 (x*x)n/2 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。

# 搜索

### 12 矩阵中的路径

[牛客网](https://www.nowcoder.com/practice/69fe7a584f0a445da1b6652978de5c38?tpId=13&tqId=11218&tab=answerKey&from=cyc_github)

